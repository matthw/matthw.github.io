<!DOCTYPE html>
<html lang="en-us">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<meta name="theme-color" content="#494f5c">
	<meta name="msapplication-TileColor" content="#494f5c">
<meta itemprop="name" content="Automatically Unpacking IcedID Stage 1 with Angr">
<meta itemprop="description" content="0verfl0w posted a small challenge on the Zero 2 Automated discord server asking to automatically extract the configuration of an unpacked IcedID sample (0581f0bf260a11a5662d58b99a82ec756c9365613833bce8f102ec1235a7d4f7).
Unpacking the sample was part of the exercise but could be done manually as a one shot, however the more I looked into the stager, the more i though an automated unpacker would be a fun thing to do.
I&rsquo;ll skip over some details of stagers (like API hashing and injection) to focus only on the unpacking."><meta itemprop="datePublished" content="2022-05-30T09:15:00+02:00" />
<meta itemprop="dateModified" content="2022-05-30T09:15:00+02:00" />
<meta itemprop="wordCount" content="3984">
<meta itemprop="keywords" content="reverse,malware,icedid," /><meta property="og:title" content="Automatically Unpacking IcedID Stage 1 with Angr" />
<meta property="og:description" content="0verfl0w posted a small challenge on the Zero 2 Automated discord server asking to automatically extract the configuration of an unpacked IcedID sample (0581f0bf260a11a5662d58b99a82ec756c9365613833bce8f102ec1235a7d4f7).
Unpacking the sample was part of the exercise but could be done manually as a one shot, however the more I looked into the stager, the more i though an automated unpacker would be a fun thing to do.
I&rsquo;ll skip over some details of stagers (like API hashing and injection) to focus only on the unpacking." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://matth.dmz42.org/posts/2022/automatically-unpacking-icedid-stage1-with-angr/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-30T09:15:00+02:00" />
<meta property="article:modified_time" content="2022-05-30T09:15:00+02:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Automatically Unpacking IcedID Stage 1 with Angr"/>
<meta name="twitter:description" content="0verfl0w posted a small challenge on the Zero 2 Automated discord server asking to automatically extract the configuration of an unpacked IcedID sample (0581f0bf260a11a5662d58b99a82ec756c9365613833bce8f102ec1235a7d4f7).
Unpacking the sample was part of the exercise but could be done manually as a one shot, however the more I looked into the stager, the more i though an automated unpacker would be a fun thing to do.
I&rsquo;ll skip over some details of stagers (like API hashing and injection) to focus only on the unpacking."/>

	<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
	<link rel="manifest" href="/site.webmanifest">
	<link rel="mask-icon" href="/safari-pinned-tab.svg" color="">
	<link rel="shortcut icon" href="/favicon.ico">

	<title>Automatically Unpacking IcedID Stage 1 with Angr</title>
	<link rel="stylesheet" href="https://matth.dmz42.org/css/style.min.037b6ee8f8c1baab6a3d0a9da11c3ff18a7552471f16c59fd98538d5ce99208b.css" integrity="sha256-A3tu6PjBuqtqPQqdoRw/8Yp1UkcfFsWf2YU41c6ZIIs=" crossorigin="anonymous">
	
</head>

<body id="page">
	
	<header id="site-header" class="animated slideInUp">
		<div class="hdr-wrapper section-inner">
			<div class="hdr-left">
				<div class="site-branding">
					<a href="https://matth.dmz42.org"># matth.dmz42.org</a>
				</div>
				<nav class="site-nav hide-in-mobile">
					
				<a href="https://matth.dmz42.org/posts/">Posts</a>
				<a href="https://matth.dmz42.org/tags/">Tags</a>

				</nav>
			</div>
			<div class="hdr-right hdr-icons">
				<span class="hdr-social hide-in-mobile"><a href="https://twitter.com/matth_walter" target="_blank" rel="noopener me" title="Twitter"><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"></path></svg></a><a href="https://github.com/matthw" target="_blank" rel="noopener me" title="Github"><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path></svg></a><a href="https://www.linkedin.com/in/mwalter/" target="_blank" rel="noopener me" title="Linkedin"><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z"></path><rect x="2" y="9" width="4" height="12"></rect><circle cx="4" cy="4" r="2"></circle></svg></a></span><button id="menu-btn" class="hdr-btn" title="Menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></button>
			</div>
		</div>
	</header>
	<div id="mobile-menu" class="animated fast">
		<ul>
			<li><a href="https://matth.dmz42.org/posts/">Posts</a></li>
			<li><a href="https://matth.dmz42.org/tags/">Tags</a></li>
		</ul>
	</div>


	<main class="site-main section-inner animated fadeIn faster">
		<article class="thin">
			<header class="post-header">
				<div class="post-meta"><span>May 30, 2022</span></div>
				<h1>Automatically Unpacking IcedID Stage 1 with Angr</h1>
			</header>
			<div class="content">
				<p><a href="https://twitter.com/0verfl0w_">0verfl0w</a> posted a small challenge on the <a href="https://courses.zero2auto.com/">Zero 2 Automated</a> discord server asking to automatically extract the
configuration of an unpacked IcedID sample (<a href="https://bazaar.abuse.ch/sample/0581f0bf260a11a5662d58b99a82ec756c9365613833bce8f102ec1235a7d4f7/">0581f0bf260a11a5662d58b99a82ec756c9365613833bce8f102ec1235a7d4f7</a>).</p>
<p>Unpacking the sample was part of the exercise but could be done manually as a one shot, however the more I looked into the stager, the more i though an automated unpacker would be a fun thing
to do.</p>
<p>I&rsquo;ll skip over some details of stagers (like API hashing and injection) to focus only on the unpacking.</p>
<p><em>TL;DR: full code is available here: <a href="https://github.com/matthw/icedid_stage1_unpack">https://github.com/matthw/icedid_stage1_unpack</a>.</em></p>
<h1 id="1-structure-and-flow">1. Structure and Flow<a href="#1-structure-and-flow" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h1>
<p>The packed data are really easy to identify: there&rsquo;s a huge hex string in the data section, and by hex string i a mean littleral string of [0-9a-f] characters.</p>
<pre tabindex="0"><code>[...]
000af670  33 62 36 64 34 39 61 61  36 35 33 36 31 34 64 65  |3b6d49aa653614de|
000af680  33 31 62 32 66 64 37 31  65 64 38 66 61 30 37 63  |31b2fd71ed8fa07c|
000af690  63 34 30 39 64 64 34 38  61 65 36 35 38 39 31 61  |c409dd48ae65891a|
000af6a0  63 36 33 61 30 39 39 36  31 38 61 63 38 35 30 33  |c63a099618ac8503|
000af6b0  62 34 32 37 39 31 36 63  66 36 31 66 31 31 33 30  |b427916cf61f1130|
000af6c0  37 66 35 39 30 35 33 31  65 37 37 39 35 34 31 33  |7f590531e7795413|
000af6d0  63 64 31 62 32 30 00 00  00 00 00 00 00 00 00 00  |cd1b20..........|
</code></pre><p>The unpacking process is as follow:</p>
<pre tabindex="0"><code>             ┌────────────┐
             │            │
             │ Hex Decode │
             │            │
             └─────┬──────┘
                   │
                   │
             ┌─────▼──────┐
             │            │
       ┌─────┤    RC4     │
       │     │            │
       │     └─────┬──────┘
       │           │
       │           │
┌──────▼─────┐     │
│            │     │
│     XOR    │     │
│ (optionnal)│     │
│            │     │
└─────┬──────┘     │
      │            │
      │            │
      │      ┌─────▼──────┐
      │      │            │
      └──────►  QuickLZ   │
             │(decompress)│
             │            │
             └─────┬──────┘
                   │
                   │
             ┌─────▼──────┐
             │            │
             │   Split    │
             │            │
             └────────────┘
</code></pre><p>The control flow at assembly level is very obfuscated, so the decompiler comes handy even if it doesn&rsquo;t produces perfect results.</p>
<p><img src="obfuscated_flow.png" alt="Obfuscated control flow"></p>
<h2 id="11-hex-decode">1.1. Hex decode<a href="#11-hex-decode" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>The first step is to decode the hex string:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl">            <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">chr</span> <span class="o">=</span> <span class="n">hexencoded_data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">                <span class="n">next_chr</span> <span class="o">=</span> <span class="n">hexencoded_data</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">                
</span></span><span class="line"><span class="cl">                <span class="n">v1</span> <span class="o">=</span> <span class="n">is_valid_hex_chr</span><span class="p">(</span><span class="n">chr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                
</span></span><span class="line"><span class="cl">                <span class="cm">/* not an hex digit, ciao */</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">((</span><span class="n">v1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">v1</span> <span class="o">=</span> <span class="n">is_valid_hex_chr</span><span class="p">(</span><span class="n">next_chr</span><span class="p">),</span> <span class="n">v1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">memset</span><span class="p">((</span><span class="n">ulonglong</span><span class="p">)</span><span class="n">destination</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mh">0x10</span><span class="p">,</span><span class="n">uVar2</span><span class="p">,</span><span class="n">chr</span><span class="p">,</span><span class="n">length</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                    <span class="n">get_TEB</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">                    <span class="p">(</span><span class="o">*</span><span class="n">RtlFreeHeap</span><span class="p">)();</span>
</span></span><span class="line"><span class="cl">                    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="o">/</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="cm">/* convert 1st ascii chr to hex value, ex: &#39;a&#39; -&gt; 0xa */</span>
</span></span><span class="line"><span class="cl">                <span class="n">v1</span> <span class="o">=</span> <span class="n">hex_digit_to_int</span><span class="p">(</span><span class="n">chr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="cm">/* 0xa -&gt; 0xa0 */</span>
</span></span><span class="line"><span class="cl">                <span class="n">high4</span> <span class="o">=</span> <span class="p">(</span><span class="n">byte</span><span class="p">)(</span><span class="n">v1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="cm">/* convert 2nd ascii chr to hex value &#39;8&#39; -&gt; 0x8 */</span>
</span></span><span class="line"><span class="cl">                <span class="n">low4</span> <span class="o">=</span> <span class="n">hex_digit_to_int</span><span class="p">(</span><span class="n">next_chr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="cm">/* make it a byte: 0xa0 | 0x8 == 0xa8 */</span>
</span></span><span class="line"><span class="cl">                <span class="o">*</span><span class="p">(</span><span class="n">byte</span> <span class="o">*</span><span class="p">)(</span><span class="o">*</span><span class="n">destination</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">))</span> <span class="o">=</span> <span class="n">high4</span> <span class="o">|</span> <span class="p">(</span><span class="n">byte</span><span class="p">)</span><span class="n">low4</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span></code></pre></div><p>this is a plain equivalent to python&rsquo;s <code>bytes.fromhex(...)</code></p>
<h2 id="12-rc4">1.2. RC4<a href="#12-rc4" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>The RC4 routine is easily identified:</p>
<p><img src="rc4.png" alt="RC4"></p>
<p>The parameters 4 and 5 are respectively a pointer to the key and the length of the key (which is always 4 apparently).</p>
<h2 id="13-xor">1.3. XOR<a href="#13-xor" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>The XOR was not present in all samples i checked, but when applied, it reuses the RC4 key.</p>
<p><img src="xor.png" alt="XOR"></p>
<p>It looks intimidating but in reality it can be translated to:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span> 
</span></span><span class="line"><span class="cl">        <span class="n">data</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">data</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">^</span> <span class="n">key</span><span class="p">[</span><span class="n">x</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)])</span> <span class="o">-</span> <span class="n">data</span><span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="o">&amp;</span> <span class="mh">0xff</span>
</span></span></code></pre></div><h2 id="13-quicklz">1.3. QuickLZ<a href="#13-quicklz" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>The QuickLZ part was harder to identify.
On the first sample I analyzed, there was no compression applied, so at this point the
decrypted data looked OK</p>
<p>I could find a valid PE file inside the decrypted data:</p>
<pre tabindex="0"><code>00000db0  7c 4d 5a 90 00 03 00 00  00 04 00 00 00 ff ff 00  ||MZ.............|
00000dc0  00 b8 00 00 00 00 00 00  00 40 00 00 00 00 00 00  |.........@......|
00000dd0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
00000de0  00 00 00 00 00 00 00 00  00 00 00 00 00 d0 00 00  |................|
00000df0  00 0e 1f ba 0e 00 b4 09  cd 21 b8 01 4c cd 21 54  |.........!..L.!T|
00000e00  68 69 73 20 70 72 6f 67  72 61 6d 20 63 61 6e 6e  |his program cann|
00000e10  6f 74 20 62 65 20 72 75  6e 20 69 6e 20 44 4f 53  |ot be run in DOS|
00000e20  20 6d 6f 64 65 2e 0d 0d  0a 24 00 00 00 00 00 00  | mode....$......|
00000e30  00 21 c9 10 93 65 a8 7e  c0 65 a8 7e c0 65 a8 7e  |.!...e.~.e.~.e.~|
</code></pre><p>but i still noticed some kind of header at the very beginning of the extracted data, and that
the dword starting at offset 1 was actually the size of the data blob
<img src="header.png" alt="header"></p>
<p>I thought it was some kind of internal structure I could just ignore, until I started
having issues with some samples where the embedded PE file seemed corrupt:</p>
<pre tabindex="0"><code>00000c40  3e eb df 8f 46 03 4d 5a  90 00 03 f3 03 00 80 46  |&gt;...F.MZ.......F|
00000c50  8a 10 ff ff cd 17 20 c6  00 06 93 fb 01 00 0b f2  |...... .........|
00000c60  03 0e 1f ba 0e 00 b4 09  cd 21 b8 01 4c cd 21 54  |.........!..L.!T|
00000c70  68 69 73 20 70 72 00 00  00 80 6f 67 72 61 6d 20  |his pr....ogram |
00000c80  63 61 6e 6e 6f 74 20 62  65 20 72 75 6e 20 69 6e  |cannot be run in|
00000c90  20 44 4f 53 20 6d 6f 64  65 20 40 10 c4 2e 0d 0d  | DOS mode @.....|
00000ca0  0a 24 12 11 21 c9 10 93  65 a8 7e c0 16 01 42 6e  |.$..!...e.~...Bn|
00000cb0  05 c0 67 20 16 ca 7f c1  6e 0a 05 7f c0 4f 20 08  |..g ....n....O .|
00000cc0  0a 07 88 83 cc 7a 0a 04  83 cc 7e c1 64 0a 02 7c  |.....z....~.d..||
00000cd0  0a 02 52 69 63 68 06 0e  16 25 8b 5e 03 64 86 07  |..Rich...%.^.d..|
</code></pre><p>After some time staring at the code, it turned out that it&rsquo;s using <a href="http://www.quicklz.com/">QuickLZ</a>.</p>
<p>Major pointers were:</p>
<ul>
<li>the header format, as described <a href="https://github.com/ReSpeak/quicklz/blob/master/Format.md">here</a>:</li>
</ul>
<pre tabindex="0"><code>┌─────╥──╥──╥──╥──╥──╥──╥──╥──┐
│Flags║ Comp size ║ Dec size  │
└─────╨──╨──╨──╨──╨──╨──╨──╨──┘
</code></pre><ul>
<li>finding code like this
<img src="qlz_ghidra.png" alt="QuickLZ ghidra"></li>
</ul>
<p>looking very very similar to <a href="https://github.com/sergey-dryabzhinsky/python-quicklz/blob/master/quicklz.c#L630">https://github.com/sergey-dryabzhinsky/python-quicklz/blob/master/quicklz.c#L630</a>
<img src="qlz_github.png" alt="QuickLZ ghithub"></p>
<p>Luckily for us there&rsquo;s python bindings for QuickLZ, which work just fine: <a href="https://pypi.org/project/pyquicklz/">https://pypi.org/project/pyquicklz/</a>.</p>
<h2 id="14-split">1.4 Split<a href="#14-split" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>The decrypted data blob can be split at every occurences of the <code>|SPL|</code> marker, the string is build on the stack:
<img src="marker.png" alt="marker"></p>
<p>I kind of skipped the details in my analysis because i do not need them for now.</p>
<h1 id="2-automating">2. Automating<a href="#2-automating" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h1>
<p>Right now we have everything we need for unpacking:</p>
<ul>
<li>the data blob is easy to grab from the data section, with a regex for example</li>
<li>RC4 is vanilla</li>
<li>the XOR is easy to implement</li>
<li>QuickLZ has python bindings</li>
</ul>
<p>The only thing we need to be able to recover is the RC4/XOR key, and that&rsquo;s where the fun begins.</p>
<p>The key is not stored as data, instead it&rsquo;s computed in the code and stored on the stack:</p>
<p><img src="rc4_key.png" alt="RC4 key"></p>
<p>so in this case the key is:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">p32</span><span class="p">(</span><span class="mh">0x11c7425e</span> <span class="o">+</span> <span class="mh">0x68</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\xc6</span><span class="s1">B</span><span class="se">\xc7\x11</span><span class="s1">&#39;</span>
</span></span></code></pre></div><h2 id="21-failed-approach">2.1. Failed Approach<a href="#21-failed-approach" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>my first approach was to match the bytes using a YARA rule like:</p>
<pre tabindex="0"><code>            rule key {
                strings:
                    // C74424 34 5E42C711       | mov dword ptr ss:[rsp+34],11C7425E
                    // 834424 34 68             | add dword ptr ss:[rsp+34],68
                    $instr = { C7 44 24 ?? ?? ?? ?? ?? 8? ?? 24 ?? ?? }
                condition:
                    $instr
            }
</code></pre><p>emulate all the matches with <a href="https://www.unicorn-engine.org/">unicorn</a>, fetch the result from the stack and try all values as keys.</p>
<p>The key grabbing looked like this and worked on some samples:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">emulate</span><span class="p">(</span><span class="n">code</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34; emulate the potential key instruction and return
</span></span></span><span class="line"><span class="cl"><span class="s2">    whatever 4 byte value is on the stack (or None)
</span></span></span><span class="line"><span class="cl"><span class="s2">    &#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="n">ADDR_TEXT</span>  <span class="o">=</span> <span class="mh">0x1000000</span>
</span></span><span class="line"><span class="cl">    <span class="n">ADDR_STACK</span> <span class="o">=</span> <span class="mh">0x7000000</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">mu</span> <span class="o">=</span> <span class="n">Uc</span><span class="p">(</span><span class="n">UC_ARCH_X86</span><span class="p">,</span> <span class="n">UC_MODE_64</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">mu</span><span class="o">.</span><span class="n">mem_map</span><span class="p">(</span><span class="n">ADDR_TEXT</span><span class="p">,</span> <span class="mh">0x1000</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">mu</span><span class="o">.</span><span class="n">mem_map</span><span class="p">(</span><span class="n">ADDR_STACK</span><span class="p">,</span> <span class="mh">0x1000</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># copy code</span>
</span></span><span class="line"><span class="cl">    <span class="n">mu</span><span class="o">.</span><span class="n">mem_write</span><span class="p">(</span><span class="n">ADDR_TEXT</span><span class="p">,</span> <span class="n">code</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># init rsp</span>
</span></span><span class="line"><span class="cl">    <span class="n">mu</span><span class="o">.</span><span class="n">reg_write</span><span class="p">(</span><span class="n">UC_X86_REG_RSP</span><span class="p">,</span> <span class="n">ADDR_STACK</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># emulate</span>
</span></span><span class="line"><span class="cl">    <span class="k">try</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">mu</span><span class="o">.</span><span class="n">emu_start</span><span class="p">(</span><span class="n">ADDR_TEXT</span><span class="p">,</span> <span class="n">ADDR_TEXT</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">code</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="k">except</span> <span class="n">unicorn</span><span class="o">.</span><span class="n">UcError</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">pass</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># read stack</span>
</span></span><span class="line"><span class="cl">    <span class="n">stack</span> <span class="o">=</span> <span class="n">mu</span><span class="o">.</span><span class="n">mem_read</span><span class="p">(</span><span class="n">ADDR_STACK</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># assume there&#39;s no null byte</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">[</span><span class="n">stack</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">4</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">),</span> <span class="mi">4</span><span class="p">)]:</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">u32</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kc">None</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">find_keys</span><span class="p">(</span><span class="n">pe</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s1">&#39;&#39;&#39; find potential instructions setting the key
</span></span></span><span class="line"><span class="cl"><span class="s1">    &#39;&#39;&#39;</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># find .text</span>
</span></span><span class="line"><span class="cl">    <span class="n">data</span> <span class="o">=</span> <span class="n">get_section</span><span class="p">(</span><span class="n">pe</span><span class="p">,</span> <span class="s1">&#39;.text&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">rule</span> <span class="o">=</span> <span class="n">yara</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">source</span><span class="o">=</span><span class="s2">&#34;&#34;&#34;
</span></span></span><span class="line"><span class="cl"><span class="s2">            rule key {
</span></span></span><span class="line"><span class="cl"><span class="s2">                strings:
</span></span></span><span class="line"><span class="cl"><span class="s2">                    // C74424 34 5E42C711       | mov dword ptr ss:[rsp+34],11C7425E
</span></span></span><span class="line"><span class="cl"><span class="s2">                    // 834424 34 68             | add dword ptr ss:[rsp+34],68
</span></span></span><span class="line"><span class="cl"><span class="s2">                    $instr = { C7 44 24 ?? ?? ?? ?? ?? 8? ?? 24 ?? ?? }
</span></span></span><span class="line"><span class="cl"><span class="s2">                condition:
</span></span></span><span class="line"><span class="cl"><span class="s2">                    $instr
</span></span></span><span class="line"><span class="cl"><span class="s2">            }&#34;&#34;&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">finds</span> <span class="o">=</span> <span class="n">rule</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># potential code snippet setting the key</span>
</span></span><span class="line"><span class="cl">    <span class="n">key_code</span> <span class="o">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">find</span> <span class="ow">in</span> <span class="n">finds</span><span class="p">[</span><span class="s1">&#39;main&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;strings&#39;</span><span class="p">]:</span>
</span></span><span class="line"><span class="cl">        <span class="n">offset</span> <span class="o">=</span> <span class="n">find</span><span class="p">[</span><span class="s1">&#39;offset&#39;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="n">string</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">offset</span><span class="p">:</span><span class="n">offset</span><span class="o">+</span><span class="mi">16</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">string</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="n">string</span><span class="p">[</span><span class="mi">11</span><span class="p">]:</span>
</span></span><span class="line"><span class="cl">            <span class="c1">#print(string)</span>
</span></span><span class="line"><span class="cl">            <span class="n">key_code</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">potential_keys</span> <span class="o">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">code</span> <span class="ow">in</span> <span class="n">key_code</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;--- emulating:&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="c1">#disasm(code)</span>
</span></span><span class="line"><span class="cl">        <span class="n">key</span> <span class="o">=</span> <span class="n">emulate</span><span class="p">(</span><span class="n">code</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1"># assume no null byte in key</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">key</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x00</span><span class="s1">&#39;</span> <span class="ow">in</span> <span class="n">key</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">potential_keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">potential_keys</span>
</span></span></code></pre></div><pre tabindex="0"><code> ./unpack2.py 0581f0bf260a11a5662d58b99a82ec756c9365613833bce8f102ec1235a7d4f7.bin
--- emulating:
0x1000:	mov	dword ptr [rsp + 0x20], 4
0x1008:	add	dword ptr [rsp + 0x20], 0
0x100d:	jmp	0x1067
--- emulating:
0x1000:	mov	dword ptr [rsp + 0x34], 0x11c7425e
0x1008:	add	dword ptr [rsp + 0x34], 0x68
--- emulating:
0x1000:	mov	dword ptr [rsp + 0x14], 0xa6
0x1008:	add	dword ptr [rsp + 0x14], 0x5a
--- emulating:
0x1000:	mov	dword ptr [rsp + 0x20], 1
0x1008:	add	dword ptr [rsp + 0x20], 0
0x100d:	jmp	0x101f
--- emulating:
0x1000:	mov	dword ptr [rsp + 0x60], 0
0x1008:	add	dword ptr [rsp + 0x60], 2
0x100d:	jmp	0xfda
--- emulating:
0x1000:	mov	dword ptr [rsp + 0x50], 2
0x1008:	add	dword ptr [rsp + 0x50], 2
0x100d:	cmp	bl, bl
--- emulating:
0x1000:	mov	dword ptr [rsp + 0x70], 0
0x1008:	add	dword ptr [rsp + 0x70], 3
0x100d:	cmp	bp, bp
--- emulating:
0x1000:	mov	dword ptr [rsp + 0x28], 0x800000e0
0x1008:	sub	dword ptr [rsp + 0x28], 0xe0
--- emulating:
0x1000:	mov	dword ptr [rsp + 0x28], 0x800000e0
0x1008:	sub	dword ptr [rsp + 0x28], 0xe0
--- emulating:
0x1000:	mov	dword ptr [rsp + 0x44], 0
0x1008:	add	dword ptr [rsp + 0x44], 3
--- emulating:
0x1000:	mov	dword ptr [rsp + 0x24], 4
0x1008:	add	dword ptr [rsp + 0x24], 0
0x100d:	jmp	0x1073
--- emulating:
0x1000:	mov	dword ptr [rsp + 0x28], 0x800000e0
0x1008:	sub	dword ptr [rsp + 0x28], 0xe0
--- emulating:
0x1000:	mov	dword ptr [rsp + 0x24], 3
0x1008:	add	dword ptr [rsp + 0x24], 1
0x100d:	jmp	0x1086
--- emulating:
0x1000:	mov	dword ptr [rsp + 0x24], 1
0x1008:	add	dword ptr [rsp + 0x24], 0
0x100d:	jmp	0x100f
--- emulating:
0x1000:	mov	dword ptr [rsp + 0x28], 1
0x1008:	add	dword ptr [rsp + 0x28], 0
0x100d:	jmp	0x1050
0x100f:	nop
--- emulating:
0x1000:	mov	dword ptr [rsp + 0x28], 3
0x1008:	add	dword ptr [rsp + 0x28], 1
0x100d:	jmp	0xff6
--- emulating:
0x1000:	mov	dword ptr [rsp + 0x28], 0x7ffffa1
0x1008:	add	dword ptr [rsp + 0x28], 0x5f
0x100d:	cmp	di, di
found 1 potential keys: [b&#39;\xc6B\xc7\x11&#39;]
got 0x4c04b data blob
decrypted data
- dump 0581f0bf260a11a5662d58b99a82ec756c9365613833bce8f102ec1235a7d4f7.bin.dump
found 5 elements
- dumped 0581f0bf260a11a5662d58b99a82ec756c9365613833bce8f102ec1235a7d4f7.bin.extracted.0
- dumped 0581f0bf260a11a5662d58b99a82ec756c9365613833bce8f102ec1235a7d4f7.bin.extracted.1
- dumped 0581f0bf260a11a5662d58b99a82ec756c9365613833bce8f102ec1235a7d4f7.bin.extracted.2
- dumped 0581f0bf260a11a5662d58b99a82ec756c9365613833bce8f102ec1235a7d4f7.bin.extracted.3
- dumped 0581f0bf260a11a5662d58b99a82ec756c9365613833bce8f102ec1235a7d4f7.bin.extracted.4
</code></pre><p>until the flow obfuscation of some samples brought even more fun to the party by putting a jump right in the middle of the key setting:
<img src="rc4_key_obf1.png" alt="RC4 key 1"></p>
<p><img src="rc4_key_obf2.png" alt="RC4 key 2"></p>
<p>rendering my initial and pretty naive approach useless.</p>
<h2 id="22-angr">2.2. Angr<a href="#22-angr" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>I only played with <a href="https://angr.io/">angr</a> before to solve crackmes and CTF challenges, and I wanted to do something else with it to practice (because let&rsquo;s face it, i&rsquo;m pretty bad with angr).</p>
<p>To quote their website:</p>
<pre tabindex="0"><code>angr is an open-source binary analysis platform for Python.
It combines both static and dynamic symbolic (&#34;concolic&#34;) analysis, providing tools to solve a variety of tasks.
</code></pre><p>My new goal was:</p>
<ul>
<li>Identify the RC4 function using some heuristics</li>
<li>Walk the control-flow graph (CFG) up to find where it&rsquo;s called from</li>
<li>Execute the function(s) calling the RC4 function up to the actual call</li>
<li>Get the key</li>
</ul>
<pre tabindex="0"><code>                              ┌────────────────────────────────────────────┐
                              │   FUNCTION WHATEVER                        │
                              │                                            │
                              ├────────────────────────────────────────────┤    step5: emulate from
                              │                                            ├────┐    0x0332 (function start)
                     ┌───────►│  0x0332    INSTR1                          │    │     to
step4: find function │        │  0x0334    INSTR2                          │    │    0x0456 (call rc4)
          start addr │        │     etc...                                 │    │
            0x332    │        │     ...                                    │    │
                     └────────┤     ...                                    │    │
                              │     ...                                    │    │
                     ┌───────►│  0x0456    CALL POTENTIAL_RC4              │ ◄──┘
                     │        │     ...                                    │    step6: dump the key parameter
                     │        │     ...                                    │
                     │        │     ...                                    │
step3: find XREF     │        │                                            │
       for 0x1234    │        │                                            │
       -&gt;  0x0456    │        │                                            │
                     │        └────────────────────────────────────────────┘
                     │
                     │
                     │
                     │        ┌────────────────────────────────────────────┐
                     │        │   FUCTION POTENTIAL_RC4                    │
                     └────────┤                                            │
                              ├────────────────────────────────────────────┤
                              │                                            │
                     ┌──────► │ 0x1234     INSTR1                          │
                     │        │ 0x1236     INSTR2                          │
step2: find function │        │     etc...                                 │
          start addr │        │                                            │   step1: find offset with
            0x1234   │        │    ─────┐ ◄────────────────────────────────┼────────  heuristic (0x1430)
                     │        │ 0x1430  │  xor     eax, ecx                │
                     └────────┤ 0x1432  │  movsxd  rcx, dword [var_18h_2]  │
                              │   ──────┘                                  │
                              │                                            │
                              │                                            │
                              └────────────────────────────────────────────┘
</code></pre><p>Luckily <code>angr</code> can provide a CFG and has a sense of &ldquo;<em>function</em>&rdquo;.</p>
<p>We can define a project and get the CFG:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">prj</span> <span class="o">=</span> <span class="n">angr</span><span class="o">.</span><span class="n">Project</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">load_options</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;auto_load_libs&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">})</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">cfg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prj</span><span class="o">.</span><span class="n">analyses</span><span class="o">.</span><span class="n">CFGFast</span><span class="p">()</span>
</span></span></code></pre></div><h3 id="221-finding-the-rc4-function">2.2.1. Finding the RC4 Function<a href="#221-finding-the-rc4-function" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>I used some loosy heuristic to find the RC4 but it seems to work well:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl">       <span class="c1"># find .text</span>
</span></span><span class="line"><span class="cl">        <span class="n">section</span> <span class="o">=</span> <span class="n">get_section</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pe</span><span class="p">,</span> <span class="s1">&#39;.text&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">data</span> <span class="o">=</span> <span class="n">section</span><span class="o">.</span><span class="n">get_data</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1"># oddly enough this seems to match the rc4 function</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># fairly accurately</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># like</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 0x1800027c2      33c1                   xor     eax, ecx</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 0x1800027c4      48634c2418             movsxd  rcx, dword [var_18h_2]</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># or</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 0x180004242      0fb68c0cd0000000       movzx   ecx, byte [rsp + rcx + 0xd0]</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 0x18000424a      33c1                   xor     eax, ecx</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 0x18000424c      e974feffff             jmp     0x1800040c5 ; fcn.180003bbf+0x506</span>
</span></span><span class="line"><span class="cl">        <span class="n">rule</span> <span class="o">=</span> <span class="n">yara</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">source</span><span class="o">=</span><span class="s2">&#34;&#34;&#34;
</span></span></span><span class="line"><span class="cl"><span class="s2">            rule rc4 {
</span></span></span><span class="line"><span class="cl"><span class="s2">                strings:
</span></span></span><span class="line"><span class="cl"><span class="s2">                    //$s1 = { 33 c1 }
</span></span></span><span class="line"><span class="cl"><span class="s2">                    $s2 = { 33 c1 48 63 4c 24 ?? }
</span></span></span><span class="line"><span class="cl"><span class="s2">                    $s3 = { 33 c1 (e9 | 3a) }
</span></span></span><span class="line"><span class="cl"><span class="s2">                condition:
</span></span></span><span class="line"><span class="cl"><span class="s2">                    $s2 or $s3
</span></span></span><span class="line"><span class="cl"><span class="s2">            }&#34;&#34;&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1"># get matching offsets</span>
</span></span><span class="line"><span class="cl">        <span class="n">finds</span> <span class="o">=</span> <span class="n">rule</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>
</span></span></code></pre></div><p>Then we just need to fix the offsets - which are relative to the start of <code>.text</code>, so they match the RVA:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl">        <span class="n">offsets</span> <span class="o">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">find</span> <span class="ow">in</span> <span class="n">finds</span><span class="p">[</span><span class="s1">&#39;main&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;strings&#39;</span><span class="p">]:</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># offset are relative to .text, rebase them</span>
</span></span><span class="line"><span class="cl">            <span class="n">off</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pe</span><span class="o">.</span><span class="n">OPTIONAL_HEADER</span><span class="o">.</span><span class="n">ImageBase</span> <span class="o">+</span> <span class="n">section</span><span class="o">.</span><span class="n">VirtualAddress</span> <span class="o">+</span> <span class="n">find</span><span class="p">[</span><span class="s1">&#39;offset&#39;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">            <span class="n">offsets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">off</span><span class="p">)</span>
</span></span></code></pre></div><p>Using these offsets, we can find the start of the function they live in:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">offset</span> <span class="ow">in</span> <span class="n">offsets</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># find function containg the offset</span>
</span></span><span class="line"><span class="cl">            <span class="n">func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_func_addr</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="n">func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;skip 0x</span><span class="si">%x</span><span class="s2">: not part of a func...&#34;</span><span class="o">%</span><span class="n">offset</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="k">continue</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">predecessors</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">                <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;skip 0x</span><span class="si">%x</span><span class="s2">: no predecessor...&#34;</span><span class="o">%</span><span class="n">offset</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="k">continue</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">predecessors</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;skip 0x</span><span class="si">%s</span><span class="s2">: too many predecessors (</span><span class="si">%d</span><span class="s2">)&#34;</span><span class="o">%</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">addr</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">predecessors</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">                <span class="k">continue</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;found potential rc4 code: 0x</span><span class="si">%x</span><span class="s2">&#34;</span><span class="o">%</span><span class="n">func</span><span class="o">.</span><span class="n">addr</span><span class="p">)</span>
</span></span></code></pre></div><p>We discard the offsets if:</p>
<ul>
<li>they do not belong to a function</li>
<li>they belong to a function with no predecessors (meaning it&rsquo;s not called)</li>
<li>they belong to a function with more than 2 predecessors (called from more than 2 different places)
<ul>
<li><em>the RC4 function should only be called from one place - 2 is being conservative</em></li>
</ul>
</li>
</ul>
<p>Now that we have the start address of a <em>potential</em> RC4 function, we need to:</p>
<ul>
<li>find the XREF (the <code>CALL rc4</code>)</li>
<li>find the calling function start address</li>
</ul>
<p>Which is just repeating what we just did:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl">            <span class="c1"># list of (start_addr, stop_addr) to emulate</span>
</span></span><span class="line"><span class="cl">            <span class="n">explorer</span> <span class="o">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="n">pred</span> <span class="ow">in</span> <span class="n">func</span><span class="o">.</span><span class="n">predecessors</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="n">caller</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_func_addr</span><span class="p">(</span><span class="n">pred</span><span class="o">.</span><span class="n">addr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="c1"># skip some cases where start_addr == stop_addr</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="n">caller</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">caller</span><span class="o">.</span><span class="n">addr</span> <span class="o">!=</span> <span class="n">pred</span><span class="o">.</span><span class="n">addr</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                    <span class="n">explorer</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">caller</span><span class="o">.</span><span class="n">addr</span><span class="p">,</span> <span class="n">pred</span><span class="o">.</span><span class="n">addr</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34; * found caller (0x</span><span class="si">%x</span><span class="s2"> -&gt; 0x</span><span class="si">%x</span><span class="s2">)&#34;</span><span class="o">%</span><span class="p">(</span><span class="n">caller</span><span class="o">.</span><span class="n">addr</span><span class="p">,</span> <span class="n">pred</span><span class="o">.</span><span class="n">addr</span><span class="p">))</span>
</span></span></code></pre></div><p>At this stage, we should have a list in the form of:</p>
<pre tabindex="0"><code>explorer = [
    (addr_start_func1, addr_call_rc4_in_func1),
    (addr_start_func2, addr_call_rc4_in_func2),
    ...
]
</code></pre><p>We can just emulate from the <code>function start address</code> to the <code>call rc4 function address</code> and dump the key from register <code>r9</code> (according to the <a href="https://docs.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-170">x64 fastcall convention</a>, r9 holds the 4th parameter - the pointer to the key in our case).</p>
<h3 id="222-emulation">2.2.2. Emulation<a href="#222-emulation" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>The emulation goes as follow:</p>
<ul>
<li>create an initial state simulating a function call at our start address
<ul>
<li><em>we use the <code>CALLLESS</code> option to skip over function calls as they are not related to the key computation</em></li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prj</span><span class="o">.</span><span class="n">factory</span><span class="o">.</span><span class="n">call_state</span><span class="p">(</span><span class="n">addr</span><span class="o">=</span><span class="n">start_addr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">state</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">angr</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">CALLLESS</span><span class="p">)</span>
</span></span></code></pre></div><ul>
<li>create a <code>Simulation Manager</code> and then <code>step</code> until one of the state reachs our destination address</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">simgr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prj</span><span class="o">.</span><span class="n">factory</span><span class="o">.</span><span class="n">simulation_manager</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">simgr</span><span class="o">.</span><span class="n">step</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">simgr</span><span class="o">.</span><span class="n">active</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_state</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">stop_addr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">key</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">key</span>
</span></span></code></pre></div><p>with a few extra conditions to avoid looping when there&rsquo;s no active path left or when the paths gets too complex (arbitrary pick), it looks like this:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">emulate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_addr</span><span class="p">,</span> <span class="n">stop_addr</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">3000</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="s2">&#34;&#34;&#34; symbolic execution from start_addr to stop_addr.
</span></span></span><span class="line"><span class="cl"><span class="s2">        max_iter is the maximum number of instructions
</span></span></span><span class="line"><span class="cl"><span class="s2">
</span></span></span><span class="line"><span class="cl"><span class="s2">        return None if failed, or [r9]
</span></span></span><span class="line"><span class="cl"><span class="s2">        &#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;emulating from 0x</span><span class="si">%x</span><span class="s2"> to 0x</span><span class="si">%x</span><span class="s2"> (max iter = </span><span class="si">%s</span><span class="s2">)&#34;</span><span class="o">%</span><span class="p">(</span><span class="n">start_addr</span><span class="p">,</span> <span class="n">stop_addr</span><span class="p">,</span> <span class="n">max_iter</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prj</span><span class="o">.</span><span class="n">factory</span><span class="o">.</span><span class="n">call_state</span><span class="p">(</span><span class="n">addr</span><span class="o">=</span><span class="n">start_addr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1"># no function call</span>
</span></span><span class="line"><span class="cl">        <span class="n">state</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">angr</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">CALLLESS</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">simgr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prj</span><span class="o">.</span><span class="n">factory</span><span class="o">.</span><span class="n">simulation_manager</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># advance all states by one basic block</span>
</span></span><span class="line"><span class="cl">            <span class="n">simgr</span><span class="o">.</span><span class="n">step</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">            <span class="n">max_iter</span> <span class="o">-=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1"># very arbitrary picks</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># we shouldnt run into too complex paths</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="ow">not</span> <span class="n">max_iter</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">simgr</span><span class="o">.</span><span class="n">active</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">10</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">simgr</span><span class="o">.</span><span class="n">active</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="kc">None</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1"># check each active</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">simgr</span><span class="o">.</span><span class="n">active</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_state</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">stop_addr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="n">key</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                    <span class="k">return</span> <span class="n">key</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="kc">None</span>
</span></span></code></pre></div><p>The <code>check_state</code> function will check if the current state address is the destination address, and if so, will dereference the value of the R9 register (4th parameter)
and read a DWORD in there.</p>
<p>I assume the key is always 4 bytes long, however should it not be the case, its length can be read from the stack (5th function parameter).</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">check_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">stop_addr</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="s2">&#34;&#34;&#34; check if a state reached the expected address)
</span></span></span><span class="line"><span class="cl"><span class="s2">            hook potential call with unconstrained destinatinations
</span></span></span><span class="line"><span class="cl"><span class="s2">
</span></span></span><span class="line"><span class="cl"><span class="s2">            returns the key if arrived at destination
</span></span></span><span class="line"><span class="cl"><span class="s2">        &#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1"># final destination</span>
</span></span><span class="line"><span class="cl">        <span class="c1">#if state.addr in range(stop_addr, stop_addr+8):</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">addr</span> <span class="o">==</span> <span class="n">stop_addr</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># dereference r9 register and read a DWORD</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># we assume the key is 4 bytes, we could read its size off the stack</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">p32</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">mem</span><span class="p">[</span><span class="n">state</span><span class="o">.</span><span class="n">regs</span><span class="o">.</span><span class="n">r9</span><span class="p">]</span><span class="o">.</span><span class="n">uint32_t</span><span class="o">.</span><span class="n">resolved</span><span class="p">))</span>
</span></span></code></pre></div><p>There&rsquo;s an extra twist in the <code>check_state</code> function.</p>
<p>The sample uses API hashing to resolve api proc addresses, and we explicitly told angr to skip function calls (<em>CALLLESS</em>).
The effect of the CALLLESS flag is that the return value of all function calls will be unconstrained (symbolic).</p>
<p>So what should have been:</p>
<pre tabindex="0"><code>address = get_proc_address(0x12345678) // return 0x18032323
(*0x12345678)(arg1, arg2)
</code></pre><p>becomes:</p>
<pre tabindex="0"><code>address = get_proc_address(0x12345678) // return some symbolic constant
(*????????)(arg1, arg2)
</code></pre><p>and basically angr stops because there&rsquo;s too many possible paths (for some reason, even with the <code>CALLLESS</code>flag).</p>
<p><img src="api_1.png" alt="api1"></p>
<p>call to resolved function (call to a stack address):
<img src="api_2.png" alt="api2"></p>
<p>My work around to that was to hook all <code>CALL</code>instructions to a temp address by:</p>
<ul>
<li>checking if the node successor is reached via a call:</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">if</span> <span class="n">block</span><span class="o">.</span><span class="n">vex</span><span class="o">.</span><span class="n">jumpkind</span> <span class="o">==</span> <span class="s1">&#39;Ijk_Call&#39;</span><span class="p">:</span>
</span></span></code></pre></div><ul>
<li>then checking if the call uses a temp value:</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">if</span> <span class="n">block</span><span class="o">.</span><span class="n">vex</span><span class="o">.</span><span class="n">next</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s1">&#39;Iex_RdTmp&#39;</span><span class="p">:</span>
</span></span></code></pre></div><ul>
<li>looping over the block instruction to find the actuall call and hooking it with something of ours:</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl">                <span class="k">for</span> <span class="n">insn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">prj</span><span class="o">.</span><span class="n">factory</span><span class="o">.</span><span class="n">block</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">addr</span><span class="p">)</span><span class="o">.</span><span class="n">capstone</span><span class="o">.</span><span class="n">insns</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                    <span class="k">if</span> <span class="n">insn</span><span class="o">.</span><span class="n">mnemonic</span> <span class="o">==</span> <span class="s1">&#39;call&#39;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                        <span class="k">if</span> <span class="n">insn</span><span class="o">.</span><span class="n">address</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">hooks</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                            <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;hooking addr=0x</span><span class="si">%x</span><span class="s2"> size=</span><span class="si">%s</span><span class="s2">&#34;</span><span class="o">%</span><span class="p">(</span><span class="n">insn</span><span class="o">.</span><span class="n">address</span><span class="p">,</span> <span class="n">insn</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                            <span class="bp">self</span><span class="o">.</span><span class="n">prj</span><span class="o">.</span><span class="n">hook</span><span class="p">(</span><span class="n">insn</span><span class="o">.</span><span class="n">address</span><span class="p">,</span> <span class="n">hook_api_hash</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="n">insn</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                            <span class="c1"># in order to avoid hook twice // angr would warn anyway</span>
</span></span><span class="line"><span class="cl">                            <span class="bp">self</span><span class="o">.</span><span class="n">hooks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">insn</span><span class="o">.</span><span class="n">address</span><span class="p">)</span>
</span></span></code></pre></div><p>The hook is very simple and looks like that:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">hook_api_hash</span><span class="p">(</span><span class="n">state</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34; hook register calls with this
</span></span></span><span class="line"><span class="cl"><span class="s2">    &#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># symbolize return value</span>
</span></span><span class="line"><span class="cl">    <span class="n">state</span><span class="o">.</span><span class="n">regs</span><span class="o">.</span><span class="n">rax</span> <span class="o">=</span> <span class="n">claripy</span><span class="o">.</span><span class="n">BVS</span><span class="p">(</span><span class="s1">&#39;ret&#39;</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>
</span></span></code></pre></div><p>The full <code>check_state</code> function looks like this:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">check_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">stop_addr</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="s2">&#34;&#34;&#34; check if a state reached the expected address)
</span></span></span><span class="line"><span class="cl"><span class="s2">            hook potential call with unconstrained destinatinations
</span></span></span><span class="line"><span class="cl"><span class="s2">
</span></span></span><span class="line"><span class="cl"><span class="s2">            returns the key if arrived at destination
</span></span></span><span class="line"><span class="cl"><span class="s2">        &#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1"># final destination</span>
</span></span><span class="line"><span class="cl">        <span class="c1">#if state.addr in range(stop_addr, stop_addr+8):</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">addr</span> <span class="o">==</span> <span class="n">stop_addr</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># dereference r9 register and read a DWORD</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># we assume the key is 4 bytes, we could read its size off the stack</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">p32</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">mem</span><span class="p">[</span><span class="n">state</span><span class="o">.</span><span class="n">regs</span><span class="o">.</span><span class="n">r9</span><span class="p">]</span><span class="o">.</span><span class="n">uint32_t</span><span class="o">.</span><span class="n">resolved</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">#</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># hook registers calls (api hashing)</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># we want to hook all &#34;call $tmp&#34;, otherwise angr gets lost</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># even with angr.options.CALLLESS</span>
</span></span><span class="line"><span class="cl">        <span class="c1">#</span>
</span></span><span class="line"><span class="cl">        <span class="k">try</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">block</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">block</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="k">except</span> <span class="n">angr</span><span class="o">.</span><span class="n">errors</span><span class="o">.</span><span class="n">SimEngineError</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="kc">None</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1"># verify that the block ends with a call</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">block</span><span class="o">.</span><span class="n">vex</span><span class="o">.</span><span class="n">jumpkind</span> <span class="o">==</span> <span class="s1">&#39;Ijk_Call&#39;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># the next block is based on tmp value</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="n">block</span><span class="o">.</span><span class="n">vex</span><span class="o">.</span><span class="n">next</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s1">&#39;Iex_RdTmp&#39;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="c1"># iterates over block instructions to find the call addr and size</span>
</span></span><span class="line"><span class="cl">                <span class="k">for</span> <span class="n">insn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">prj</span><span class="o">.</span><span class="n">factory</span><span class="o">.</span><span class="n">block</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">addr</span><span class="p">)</span><span class="o">.</span><span class="n">capstone</span><span class="o">.</span><span class="n">insns</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                    <span class="k">if</span> <span class="n">insn</span><span class="o">.</span><span class="n">mnemonic</span> <span class="o">==</span> <span class="s1">&#39;call&#39;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                        <span class="k">if</span> <span class="n">insn</span><span class="o">.</span><span class="n">address</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">hooks</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                            <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;hooking addr=0x</span><span class="si">%x</span><span class="s2"> size=</span><span class="si">%s</span><span class="s2">&#34;</span><span class="o">%</span><span class="p">(</span><span class="n">insn</span><span class="o">.</span><span class="n">address</span><span class="p">,</span> <span class="n">insn</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                            <span class="bp">self</span><span class="o">.</span><span class="n">prj</span><span class="o">.</span><span class="n">hook</span><span class="p">(</span><span class="n">insn</span><span class="o">.</span><span class="n">address</span><span class="p">,</span> <span class="n">hook_api_hash</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="n">insn</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                            <span class="c1"># in order to avoid hook twice // angr would warn anyway</span>
</span></span><span class="line"><span class="cl">                            <span class="bp">self</span><span class="o">.</span><span class="n">hooks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">insn</span><span class="o">.</span><span class="n">address</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="kc">None</span>
</span></span></code></pre></div><p>in the end we, we can just loop over the <code>(start_addr, stop_addr)</code> tupples, to get a list of potential RC4 keys:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl">        <span class="c1"># emulate all potential calls</span>
</span></span><span class="line"><span class="cl">        <span class="n">potential_keys</span> <span class="o">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span> <span class="ow">in</span> <span class="n">explorer</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># emulate</span>
</span></span><span class="line"><span class="cl">            <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">emulate</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="n">key</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="n">potential_keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">potential_keys</span>
</span></span></code></pre></div><h2 id="23-decrypting">2.3. Decrypting<a href="#23-decrypting" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>now that we constructed a list of potential keys, we can just try them all.
using the QuickLZ header, we can know that we found a correct one by matching the size of the data with what&rsquo;s in the header:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">try_to_decrypt</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">potential_keys</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s1">&#39;&#39;&#39; try all keys with xor and without
</span></span></span><span class="line"><span class="cl"><span class="s1">        it seems the xor is not always applied
</span></span></span><span class="line"><span class="cl"><span class="s1">    &#39;&#39;&#39;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">potential_keys</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">apply_xor</span> <span class="ow">in</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">]:</span>
</span></span><span class="line"><span class="cl">            <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;trying key </span><span class="si">%r</span><span class="s2"> / xor=</span><span class="si">%r</span><span class="s2">&#34;</span><span class="o">%</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">apply_xor</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">            <span class="n">dec</span> <span class="o">=</span> <span class="n">decrypt</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">apply_xor</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="n">dec</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="n">dec</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kc">None</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">decrypt</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">apply_xor</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s1">&#39;&#39;&#39; decrypt + decompress data
</span></span></span><span class="line"><span class="cl"><span class="s1">    &#39;&#39;&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># RC4 decrypt</span>
</span></span><span class="line"><span class="cl">    <span class="n">cipher</span> <span class="o">=</span> <span class="n">ARC4</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">dec</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">cipher</span><span class="o">.</span><span class="n">decrypt</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># dexor</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">apply_xor</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dec</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">            <span class="n">dec</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">dec</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">^</span> <span class="n">key</span><span class="p">[</span><span class="n">x</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)])</span> <span class="o">-</span> <span class="n">dec</span><span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="o">&amp;</span> <span class="mh">0xff</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># Quick check we got valid data</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># ref: quicklz format: https://github.com/ReSpeak/quicklz/blob/master/Format.md</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># DWORD at decrypted data+1 should be the length</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">u32</span><span class="p">(</span><span class="n">dec</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">5</span><span class="p">])</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">quicklz</span><span class="o">.</span><span class="n">decompress</span><span class="p">(</span><span class="nb">bytes</span><span class="p">(</span><span class="n">dec</span><span class="p">))</span>
</span></span></code></pre></div><p>The XOR pass doesn&rsquo;t seem to always be applied, so we try with and without.</p>
<h1 id="3-c2-extraction">3. C2 Extraction<a href="#3-c2-extraction" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h1>
<p>Extracting the C2 address and campain ID from the unpacked PE is pretty straight forward.</p>
<p>We just need to XOR 2 32 bytes data blob (from the <code>.d</code> section) with each other:</p>
<p><img src="c2_xor.png" alt="C2 XOR"></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">extract_c2</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">pe</span> <span class="o">=</span> <span class="n">pefile</span><span class="o">.</span><span class="n">PE</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">data</span> <span class="o">=</span> <span class="n">get_section</span><span class="p">(</span><span class="n">pe</span><span class="p">,</span> <span class="s2">&#34;.d&#34;</span><span class="p">)</span><span class="o">.</span><span class="n">get_data</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="n">key</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:</span><span class="mh">0x20</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">conf</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mh">0x40</span><span class="p">:</span><span class="mh">0x40</span><span class="o">+</span><span class="mh">0x20</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">data</span> <span class="o">=</span> <span class="n">xor</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">conf</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">camp</span> <span class="o">=</span> <span class="n">u32</span><span class="p">(</span><span class="n">data</span><span class="p">[:</span><span class="mi">4</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">    <span class="n">c2</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">4</span><span class="p">:]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x00</span><span class="s1">&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;campaign_id&#39;</span><span class="p">:</span> <span class="n">camp</span><span class="p">,</span> <span class="s1">&#39;c2&#39;</span><span class="p">:</span> <span class="n">c2</span><span class="p">}</span>
</span></span></code></pre></div><h1 id="4-showcase">4. Showcase<a href="#4-showcase" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h1>
<pre tabindex="0"><code>% ./icedid_stage1_unpack.py 0581f0bf260a11a5662d58b99a82ec756c9365613833bce8f102ec1235a7d4f7.bin
got data blob: 0x4c04b bytes
found potential rc4 code: 0x1800026b3
 * found caller (0x180001b77 -&gt; 0x180001bc0)
emulating from 0x180001b77 to 0x180001bc0 (max iter = 3000)
found 1 potential keys: [b&#39;\xc6B\xc7\x11&#39;]
trying key b&#39;\xc6B\xc7\x11&#39; / xor=True
decrypted data: 0x4c042 bytes
found 5 elements
- dumped 0581f0bf260a11a5662d58b99a82ec756c9365613833bce8f102ec1235a7d4f7.bin.extracted.0
- dumped 0581f0bf260a11a5662d58b99a82ec756c9365613833bce8f102ec1235a7d4f7.bin.extracted.1
- dumped 0581f0bf260a11a5662d58b99a82ec756c9365613833bce8f102ec1235a7d4f7.bin.extracted.2
    looks like a PE... {&#39;campaign_id&#39;: 109932505, &#39;c2&#39;: b&#39;ilekvoyn.com&#39;}
- dumped 0581f0bf260a11a5662d58b99a82ec756c9365613833bce8f102ec1235a7d4f7.bin.extracted.3
- dumped 0581f0bf260a11a5662d58b99a82ec756c9365613833bce8f102ec1235a7d4f7.bin.extracted.4
</code></pre><pre tabindex="0"><code>% ./icedid_stage1_unpack.py samples/17aeebe6c1098a312074b0fdeae6f97339f2d64d66a2b07496bfc1373694a4e3.bin
got data blob: 0x3820 bytes
found potential rc4 code: 0x180003fc1
 * found caller (0x1800011c3 -&gt; 0x180001507)
emulating from 0x1800011c3 to 0x180001507 (max iter = 3000)
found 1 potential keys: [b&#39;k\xfe\xfa\x8b&#39;]
trying key b&#39;k\xfe\xfa\x8b&#39; / xor=True
trying key b&#39;k\xfe\xfa\x8b&#39; / xor=False
decrypted data: 0x5714 bytes
found 4 elements
- dumped samples/17aeebe6c1098a312074b0fdeae6f97339f2d64d66a2b07496bfc1373694a4e3.bin.extracted.0
- dumped samples/17aeebe6c1098a312074b0fdeae6f97339f2d64d66a2b07496bfc1373694a4e3.bin.extracted.1
- dumped samples/17aeebe6c1098a312074b0fdeae6f97339f2d64d66a2b07496bfc1373694a4e3.bin.extracted.2
    looks like a PE... {&#39;campaign_id&#39;: 429479428, &#39;c2&#39;: b&#39;arelyevennot.top&#39;}
- dumped samples/17aeebe6c1098a312074b0fdeae6f97339f2d64d66a2b07496bfc1373694a4e3.bin.extracted.3
</code></pre><pre tabindex="0"><code>% ./icedid_stage1_unpack.py samples/12a692718d21b8dc3a8d5a2715688f533f1a978ee825163d41de11847039393d.bin
got data blob: 0x16064 bytes
skip 0x6442458550: too many predecessors (4)
found potential rc4 code: 0x180003bbf
 * found caller (0x1800016bf -&gt; 0x180001980)
emulating from 0x1800016bf to 0x180001980 (max iter = 3000)
hooking addr=0x18000184b size=7
hooking addr=0x180001c19 size=7
hooking addr=0x180001c09 size=7
hooking addr=0x180001bdc size=7
found 1 potential keys: [b&#39;,u\xe2I&#39;]
trying key b&#39;,u\xe2I&#39; / xor=True
decrypted data: 0x179f7 bytes
found 5 elements
- dumped samples/12a692718d21b8dc3a8d5a2715688f533f1a978ee825163d41de11847039393d.bin.extracted.0
- dumped samples/12a692718d21b8dc3a8d5a2715688f533f1a978ee825163d41de11847039393d.bin.extracted.1
- dumped samples/12a692718d21b8dc3a8d5a2715688f533f1a978ee825163d41de11847039393d.bin.extracted.2
    looks like a PE... {&#39;campaign_id&#39;: 3068011852, &#39;c2&#39;: b&#39;yolneanz.com&#39;}
- dumped samples/12a692718d21b8dc3a8d5a2715688f533f1a978ee825163d41de11847039393d.bin.extracted.3
- dumped samples/12a692718d21b8dc3a8d5a2715688f533f1a978ee825163d41de11847039393d.bin.extracted.4
</code></pre><p>The extracted data blobs are:</p>
<ul>
<li>2 shellcodes</li>
<li>1 DLL</li>
<li>1 or 2 images:</li>
</ul>
<pre tabindex="0"><code>% file 0581f0bf260a11a5662d58b99a82ec756c9365613833bce8f102ec1235a7d4f7.bin.extracted.*
0581f0bf260a11a5662d58b99a82ec756c9365613833bce8f102ec1235a7d4f7.bin.extracted.0: data
0581f0bf260a11a5662d58b99a82ec756c9365613833bce8f102ec1235a7d4f7.bin.extracted.1: data
0581f0bf260a11a5662d58b99a82ec756c9365613833bce8f102ec1235a7d4f7.bin.extracted.2: PE32+ executable (DLL) (GUI) x86-64, for MS Windows
0581f0bf260a11a5662d58b99a82ec756c9365613833bce8f102ec1235a7d4f7.bin.extracted.3: JPEG image data, JFIF standard 1.01, resolution (DPI), density 72x72, segment length 16, baseline, precision 8, 800x600, components 3
0581f0bf260a11a5662d58b99a82ec756c9365613833bce8f102ec1235a7d4f7.bin.extracted.4: JPEG image data, Exif Standard: [TIFF image data, big-endian, direntries=7, software=Adobe Photoshop 21.2 (Windows), datetime=2021-03-25T08:49:36+07:00], baseline, precision 8, 800x800, components 3
</code></pre><h1 id="5-conclusion">5. Conclusion<a href="#5-conclusion" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h1>
<p>While it is certainly not the most optimal method to unpack the samples, it was a fun exercise to do.</p>
<p>The full code is available here: <a href="https://github.com/matthw/icedid_stage1_unpack">https://github.com/matthw/icedid_stage1_unpack</a>.</p>

			</div>
			<hr class="post-end">
			<footer class="post-info">
				<p>
					<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line></svg><span class="tag"><a href="https://matth.dmz42.org/tags/reverse">reverse</a></span><span class="tag"><a href="https://matth.dmz42.org/tags/malware">malware</a></span><span class="tag"><a href="https://matth.dmz42.org/tags/icedid">icedid</a></span>
				</p>
				<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg>3984 Words</p>
				<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>2022-05-30 09:15 &#43;0200</p>
			</footer>
		</article>
		<div class="post-nav thin">
			<a class="prev-post" href="https://matth.dmz42.org/posts/2022/hackthebox-ctf-cyber-apocalypse-2022-intergalactic-chase-rev/">
				<span class="post-nav-label">Older&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></span><br><span>HackTheBox CTF Cyber Apocalypse 2022: Intergalactic Chase (Reverse)</span>
			</a>
		</div>
		<div id="comments" class="thin">
</div>
	</main>

	<footer id="site-footer" class="section-inner thin animated fadeIn faster">
		<p>&copy; 2022 <a href="https://matth.dmz42.org">Matthieu Walter</a> &#183; <a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0</a></p>
		<p>
			Made with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> &#183; Theme <a href="https://github.com/Track3/hermit" target="_blank" rel="noopener">Hermit</a> &#183; <a href="https://matth.dmz42.org/posts/index.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a>
		</p>
	</footer>



	<script src="https://matth.dmz42.org/js/bundle.min.8256b8724b9578bbdf6d6f04c894255bc760e78e8a2d60ec0a91ea993acd3b77.js" integrity="sha256-gla4ckuVeLvfbW8EyJQlW8dg546KLWDsCpHqmTrNO3c=" crossorigin="anonymous"></script>
	

</body>

</html>
